(define (enumerate-interval l h) 
  (if (> l h) 
      '() 
      (cons l (enumerate-interval (+ l 1) h)))) 
(define empty-board '()) 
(define (adjoin-position row col rest) 
  (cons (list row col) rest)) 
(define (extract item lst) 
  (define (scan items) 
    (cond ((null? items) 
          '()) 
          ((equal? item (car items)) 
          (scan (cdr items))) 
          (else (cons (car items) (scan (cdr items)))))) 
  (scan lst)) 
(define (safe? col positions) 
  (define (iter l) 
    (if (null? l) 
        true 
        (and (car l) (iter (cdr l))))) 
  (let ((row (caar (filter (lambda (p) 
                            (eq? col (cadr p))) 
                          positions)))) 
    (iter (map (lambda (p) 
                (not (or (eq? row (car p)) 
                          (eq? (- row col) (- (car p) (cadr p))) 
                          (eq? (+ row col) (+ (car p) (cadr p)))))) 
              (extract (list row col) positions))))) 
(define (queens board-size) 
  (define (queen-cols k) 
    (if (= k 0) 
        (list empty-board) 
        (map (lambda (positions) 
              (require (safe? k positions))) 
            (flatmap (lambda (rest-of-queens) 
                        (adjoin-position new-row (amb (enumerate-interval 1 board-size)) 
                                        rest-of-queens)) 
                      (queen-cols (- k 1)))))) 
  (queen-cols board-size)) 