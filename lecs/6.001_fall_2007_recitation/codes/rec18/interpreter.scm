(define (eval exp env)
  (cond ((number? exp) exp)
        ((symbol? exp) (lookup exp env))
        ((eq? (car exp) 'quote) 
          ; (display "find quote") 
          (cadr exp))
        ((eq? (car exp) 'cond)
         (eval-clauses (cdr exp) env))
        ((eq? (car exp) 'lambda)
         (eval-lambda exp env))
        (else
          ; (display "find application")
          (apply (eval (car exp) env)
                 (values (cdr exp) env)))))
(define (apply proc args)
  (cond ((primitive? proc) (papply proc args)) ; no tag
        ((eq? (car proc) 'procedure)
         (let ((parameters (cadr proc))
               (body (caddr proc))
               (env (cadddr proc)))
           (eval body
                 (extend env
                         parameters
                         args))))
        (else (error "not a proc"))))
(define (eval-lambda exp env)
  (let ((parameters (cadr exp))
        (body (caddr exp)))
    (list 'procedure parameters body env)))
(define (values exps env)
  (cond ((null? exps) '())
        (else (cons (eval (car exps) env)
                    (values (cdr exps) env)))))
(define (eval-clauses clauses env)
  (cond ((null? clauses) '())
        ((eq? (caar clauses) 'else)
         (eval (cadar clauses) env))
        ((not (eq? (eval (caar clauses) env) #f))
         (eval (cadar clauses) env))
        (else (eval-clauses (cdr clauses) env))))

;; one implementation for http://community.schemewiki.org/?sicp-ex-4.11
(define (extend base-env vars values)
  (cons (make-frame vars values) base-env))
(define (make-frame vars vals)
  (cond ((null? vars) (cond ((null? vals) '())
                            (else (error "too many args"))))
        ((null? vals) (error "too few args"))
        (else (cons (cons (car vars) (car vals))
                    (make-frame (cdr vars) (cdr vals))))))
(define (lookup var env)
  (cond ((null? env) (error "unbound variable" var))
        (else (let ((binding (assq var (car env))))
                (cond (binding (cdr binding))
                      (else (lookup var (cdr env))))))))
(define (assq var bindings)
  (cond ((null? bindings) #f)
        ((eq? (caar bindings) var) (car bindings))
        (else (assq var (cdr bindings)))))
(define (primitive? proc)
  (memq proc (list car cdr cons eq? + = > <)))
(define (papply proc args)
  (cond ((eq? proc car) (car (car args)))
        ((eq? proc cdr) (cdr (car args)))
        ((eq? proc cons) (cons (car args) (cadr args)))
        ((eq? proc eq?) (eq? (car args)))
        ((eq? proc +) (+ (car args) (cadr args)))
        ((eq? proc >) (> (car args) (cadr args)))
        ))

(define *GE*
  (extend '()
          '(car cdr cons eq? + >)
          (list car cdr cons eq? + >)))

