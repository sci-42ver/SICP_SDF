;; rec
(define (make-units C L H)
  (list C L H))
(define get-units-C car)
(define get-units-L cadr)
(define get-units-H caddr)
(define (make-class number units)
  (list number units))
(define get-class-number car)
(define get-class-units cadr)
(define (get-class-total-units class)
  (let ((units (get-class-units class)))
    (+ (get-units-C units)
       (get-units-L units)
       (get-units-H units))))
(define (same-class? c1 c2)
  (= (get-class-number c1) (get-class-number c2)))

;; 1 both O(1)
(define (empty-schedule)
  '())

;; 2 both O(1)
(define (add-class class schedule)
  (cons class schedule))

;; 3 both O(n)*map complexity which may be O(n)
(define (total-scheduled-units sched)
  (define (sum_lst lst)
    (if (null? lst)
      0
      (+ (car lst) (sum_lst (cdr lst)))))
  (sum_lst (map get-class-total-units sched)))

;; 4 Assume `append` is O(1). Then helper/drop-class is time O(n) and space O(1).
(define (drop-class sched classnum)
  (define (helper prev rest)
    (let ((cur (car sched)))
      (if (= (get-class-number cur) classnum)
          (append prev (cdr rest))
          (helper (append prev (list cur)) (cdr rest)))))
  (helper (empty-schedule) sched))

;; 5 time O(n^2) space O(1)
(define (credit-limit sched max-credits)
  (if (>= (total-scheduled-units sched) max-credits)
      (credit-limit (drop-class sched (get-class-number (car sched))) max-credits)
      sched))

(define test_units (make-units 1 2 3))
(define test_units (make-units 2 3 4))
(define test_schedule (list (make-class 100 test_units) (make-class 101 test_units)))
(add-class (make-class 102 test_units) test_schedule)
(total-scheduled-units test_schedule)
(drop-class test_schedule 100)
(credit-limit test_schedule 10)
